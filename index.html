<!DOCTYPE html>
<html lang="zh-TW" class="h-full bg-gray-50">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF 轉 EPUB 翻譯轉換器 (Azure & DeepL)</title>
    <!-- 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入 Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        #pdfFile { display: none; }
        .file-input-button { cursor: pointer; }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .progress-bar-fill { transition: width 0.3s ease-in-out; }
        /* 按鈕樣式 */
        .mode-btn, .api-btn {
            transition: all 0.2s ease-in-out;
        }
        .mode-btn.active, .api-btn.active {
            background-color: #4f46e5; /* bg-indigo-600 */
            color: white;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
    </style>
</head>
<body class="h-full flex items-center justify-center p-4 bg-gray-100">
    <div class="w-full max-w-2xl mx-auto bg-white rounded-2xl shadow-xl p-6 md:p-10 border border-gray-200">
        <div class="text-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="mx-auto h-12 w-12 text-indigo-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
            </svg>
            <h1 class="mt-4 text-2xl md:text-3xl font-bold tracking-tight text-gray-900">多功能文件轉換器</h1>
            <p class="mt-2 text-sm md:text-base text-gray-600">接受 PDF 檔案，支援輸出 EPUB/TXT，並可選用 Azure 或 DeepL 翻譯。</p>
        </div>

        <div class="mt-8 space-y-6">
            <!-- 檔案上傳區域 -->
            <div id="upload-area" class="relative block w-full rounded-lg border-2 border-dashed border-gray-300 p-8 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="mx-auto h-10 w-10 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
                <label for="pdfFile" class="mt-4 block text-sm font-medium text-indigo-600 hover:text-indigo-500 file-input-button">
                    <span>選擇一個 PDF 檔案</span>
                </label>
                <input type="file" id="pdfFile" accept="application/pdf">
                <p id="file-name" class="mt-1 text-xs text-gray-500">或將檔案拖曳到此處</p>
            </div>
            
            <!-- 模式選擇 -->
            <div id="mode-selection" class="hidden border-t border-gray-200 pt-6">
                <label class="block text-center font-medium text-gray-900 mb-3">請選擇處理模式</label>
                <div class="flex justify-center rounded-lg shadow-sm" role="group">
                    <button type="button" id="mode-convert" class="mode-btn py-2 px-4 text-sm font-medium text-gray-900 bg-white border border-gray-200 rounded-l-lg hover:bg-gray-100 focus:z-10 focus:ring-2 focus:ring-indigo-500">
                        純轉換模式
                    </button>
                    <button type="button" id="mode-translate" class="mode-btn py-2 px-4 text-sm font-medium text-gray-900 bg-white border-t border-b border-r border-gray-200 rounded-r-lg hover:bg-gray-100 focus:z-10 focus:ring-2 focus:ring-indigo-500">
                        翻譯模式
                    </button>
                </div>
            </div>

            <!-- API 選擇 (翻譯模式) -->
            <div id="api-selection" class="hidden border-t border-gray-200 pt-6">
                <label class="block text-center font-medium text-gray-900 mb-3">請選擇翻譯服務</label>
                <div class="flex justify-center rounded-lg shadow-sm" role="group">
                    <button type="button" id="api-azure" class="api-btn py-2 px-4 text-sm font-medium text-gray-900 bg-white border border-gray-200 rounded-l-lg hover:bg-gray-100 focus:z-10 focus:ring-2 focus:ring-indigo-500">
                        Azure
                    </button>
                    <button type="button" id="api-deepl" class="api-btn py-2 px-4 text-sm font-medium text-gray-900 bg-white border-t border-b border-r border-gray-200 rounded-r-lg hover:bg-gray-100 focus:z-10 focus:ring-2 focus:ring-indigo-500">
                        DeepL
                    </button>
                </div>
            </div>

            <!-- Azure API Settings (hidden by default) -->
            <div id="azure-settings" class="hidden space-y-4 border-t border-gray-200 pt-6">
                <h3 class="text-center font-medium text-gray-900">Azure 翻譯服務設定</h3>
                <div>
                    <label for="azureKey" class="block text-sm font-medium text-gray-700">Azure 訂閱金鑰 (Key)</label>
                    <input type="password" id="azureKey" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" placeholder="請輸入您的 Azure Translator Key">
                </div>
                <div>
                    <label for="azureRegion" class="block text-sm font-medium text-gray-700">Azure 區域 (Region)</label>
                    <input type="text" id="azureRegion" value="westeurope" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" placeholder="例如：eastus">
                </div>
                <div>
                    <label for="azureDelay" class="block text-sm font-medium text-gray-700">批次間延遲 (秒)</label>
                    <input type="number" id="azureDelay" value="60" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                    <p class="mt-1 text-xs text-gray-500">為符合免費方案的速率限制，程式會將請求分批。<b>建議免費方案使用者設為 60 秒。</b></p>
                </div>
                <p class="text-xs text-center text-gray-500">您的金鑰和區域資訊僅會在您的瀏覽器中使用，不會被上傳或儲存。</p>
            </div>
            
            <!-- DeepL API Settings (hidden by default) -->
            <div id="deepl-settings" class="hidden space-y-4 border-t border-gray-200 pt-6">
                <h3 class="text-center font-medium text-gray-900">DeepL 翻譯服務設定</h3>
                 <div>
                    <label for="deeplKey" class="block text-sm font-medium text-gray-700">DeepL API 金鑰 (AuthKey)</label>
                    <input type="password" id="deeplKey" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" placeholder="請輸入您的 DeepL API Key">
                </div>
                 <p class="text-xs text-center text-gray-500">您的金鑰資訊僅會在您的瀏覽器中使用，不會被上傳或儲存。</p>
            </div>

            <!-- 處理按鈕 -->
            <button id="processBtn" class="w-full flex justify-center py-3 px-4 border border-transparent rounded-md shadow-sm text-base font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:bg-gray-400 disabled:cursor-not-allowed">
                開始處理
            </button>
            
            <!-- 狀態與進度條 -->
            <div id="status" class="text-center text-gray-700 h-6 mb-2 flex items-center justify-center space-x-2"></div>
            <div id="progressBarContainer" class="w-full bg-gray-200 rounded-full h-5 hidden mb-4">
                <div id="progressBarFill" class="bg-indigo-600 h-5 rounded-full text-xs font-medium text-white text-center p-0.5 leading-none progress-bar-fill" style="width: 0%">0%</div>
            </div>

            <!-- 下載區域 -->
            <div id="download-area" class="hidden text-center border-t border-gray-200 pt-6">
                <h3 class="text-lg font-medium text-gray-900 mb-4">處理完成！請選擇下載格式：</h3>
                <div id="download-buttons-container" class="flex flex-wrap justify-center gap-4">
                    <!-- 按鈕將由 JS 動態生成 -->
                </div>
            </div>
        </div>
    </div>

    <!-- 引入函式庫 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.worker.min.js`;

        // DOM 元素
        const fileInput = document.getElementById('pdfFile');
        const fileNameDisplay = document.getElementById('file-name');
        const processBtn = document.getElementById('processBtn');
        const statusDiv = document.getElementById('status');
        const progressBarContainer = document.getElementById('progressBarContainer');
        const progressBarFill = document.getElementById('progressBarFill');
        const uploadArea = document.getElementById('upload-area');
        const modeSelection = document.getElementById('mode-selection');
        const modeConvertBtn = document.getElementById('mode-convert');
        const modeTranslateBtn = document.getElementById('mode-translate');
        const apiSelection = document.getElementById('api-selection');
        const apiAzureBtn = document.getElementById('api-azure');
        const apiDeepLBtn = document.getElementById('api-deepl');
        const downloadArea = document.getElementById('download-area');
        const downloadButtonsContainer = document.getElementById('download-buttons-container');
        const azureSettings = document.getElementById('azure-settings');
        const azureKeyInput = document.getElementById('azureKey');
        const azureRegionInput = document.getElementById('azureRegion');
        const azureDelayInput = document.getElementById('azureDelay');
        const deeplSettings = document.getElementById('deepl-settings');
        const deeplKeyInput = document.getElementById('deeplKey');


        let selectedFile = null;
        let originalChapters = [];
        let translatedChapters = [];
        let currentMode = ''; // 'convert' or 'translate'
        let currentApi = ''; // 'azure' or 'deepl'

        // 初始化
        processBtn.disabled = true;

        // --- Event Listeners ---
        fileInput.addEventListener('change', handleFileSelect);
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => uploadArea.addEventListener(eventName, preventDefaults, false));
        ['dragenter', 'dragover'].forEach(eventName => uploadArea.addEventListener(eventName, () => uploadArea.classList.add('border-indigo-500', 'bg-indigo-50'), false));
        ['dragleave', 'drop'].forEach(eventName => uploadArea.addEventListener(eventName, () => uploadArea.classList.remove('border-indigo-500', 'bg-indigo-50'), false));
        uploadArea.addEventListener('drop', handleFileDrop, false);
        
        modeConvertBtn.addEventListener('click', () => setMode('convert'));
        modeTranslateBtn.addEventListener('click', () => setMode('translate'));

        apiAzureBtn.addEventListener('click', () => setApi('azure'));
        apiDeepLBtn.addEventListener('click', () => setApi('deepl'));

        azureKeyInput.addEventListener('input', updateProcessButtonState);
        azureRegionInput.addEventListener('input', updateProcessButtonState);
        
        deeplKeyInput.addEventListener('input', updateProcessButtonState);

        processBtn.addEventListener('click', handleProcessing);

        // --- Helper Functions ---
        function sanitizeHeaderValue(value) {
            if (typeof value !== 'string') return '';
            return value.replace(/[^\x20-\x7E]/g, '');
        }

        function formatTime(totalSeconds) {
            if (totalSeconds <= 0) return '計算中...';
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.round(totalSeconds % 60);
            let timeString = '約 ';
            if (minutes > 0) {
                timeString += `${minutes} 分 `;
            }
            if (seconds > 0 || minutes === 0) {
                timeString += `${seconds} 秒`;
            }
            return timeString.trim();
        }

        // --- UI & State Management Functions ---

        function handleFileSelect(event) {
            if (event.target.files.length > 0) {
                updateSelectedFile(event.target.files[0]);
            }
        }

        function handleFileDrop(event) {
            const file = event.dataTransfer.files[0];
            if (file && file.type === 'application/pdf') {
                fileInput.files = event.dataTransfer.files;
                updateSelectedFile(file);
            }
        }

        function updateSelectedFile(file) {
            selectedFile = file;
            fileNameDisplay.textContent = selectedFile.name;
            fileNameDisplay.classList.add('font-semibold', 'text-indigo-700');
            modeSelection.classList.remove('hidden');
            resetUI();
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function setMode(mode) {
            currentMode = mode;
            modeConvertBtn.classList.toggle('active', mode === 'convert');
            modeTranslateBtn.classList.toggle('active', mode === 'translate');

            apiSelection.classList.toggle('hidden', mode !== 'translate');
            if (mode !== 'translate') {
                 setApi(''); // Reset API selection if not in translate mode
            }
            updateProcessButtonState();
        }
        
        function setApi(api) {
            currentApi = api;
            apiAzureBtn.classList.toggle('active', api === 'azure');
            apiDeepLBtn.classList.toggle('active', api === 'deepl');
            
            azureSettings.classList.toggle('hidden', api !== 'azure');
            deeplSettings.classList.toggle('hidden', api !== 'deepl');

            updateProcessButtonState();
        }

        
        function updateProcessButtonState() {
            let disabled = true;
            if (selectedFile && currentMode) {
                if (currentMode === 'translate') {
                    if (currentApi === 'azure' && azureKeyInput.value.trim() !== '' && azureRegionInput.value.trim() !== '') {
                        disabled = false;
                    } else if (currentApi === 'deepl' && deeplKeyInput.value.trim() !== '') {
                        disabled = false;
                    }
                } else { // 'convert' mode
                    disabled = false;
                }
            }
            processBtn.disabled = disabled;
        }

        function resetUI() {
            setMode('');
            azureKeyInput.value = '';
            azureRegionInput.value = 'westeurope';
            azureDelayInput.value = '60';
            deeplKeyInput.value = '';
            downloadArea.classList.add('hidden');
            updateStatus('', false);
            progressBarContainer.classList.add('hidden');
            updateProgressBar(0);
            updateProcessButtonState();
        }
        
        function setLoadingState(loading) {
            processBtn.disabled = loading;
            processBtn.textContent = loading ? '處理中...' : '開始處理';
            if (loading) {
                downloadArea.classList.add('hidden');
            }
        }

        function updateStatus(message, isLoading) {
            statusDiv.innerHTML = '';
            if (isLoading) {
                const loader = document.createElement('div');
                loader.className = 'loader';
                statusDiv.appendChild(loader);
            }
            const textNode = document.createTextNode(message);
            statusDiv.appendChild(textNode);
        }

        function updateProgressBar(percentage, text) {
            progressBarContainer.classList.remove('hidden');
            progressBarFill.style.width = `${percentage}%`;
            progressBarFill.textContent = text || `${percentage}%`;
        }

        // --- Core Processing Logic ---

        async function handleProcessing() {
            if (processBtn.disabled) return;

            setLoadingState(true);
            
            try {
                updateStatus('正在提取內文...', true);
                originalChapters = await extractTextFromPdf(selectedFile);
                
                if (currentMode === 'translate') {
                    if (currentApi === 'azure') {
                        const azureKey = sanitizeHeaderValue(azureKeyInput.value.trim());
                        const azureRegion = sanitizeHeaderValue(azureRegionInput.value.trim());
                        const azureDelay = parseInt(azureDelayInput.value, 10) * 1000;
                        translatedChapters = await translateChaptersWithAzure(originalChapters, azureKey, azureRegion, azureDelay);
                    } else if (currentApi === 'deepl') {
                        const deeplKey = deeplKeyInput.value.trim();
                        translatedChapters = await translateChaptersWithDeepL(originalChapters, deeplKey);
                    }
                } else {
                    translatedChapters = [];
                }
                
                const hasFailures = translatedChapters.some(ch => ch.includes('[翻譯失敗'));
                const finalMessage = hasFailures ? '處理完成，但部分內容翻譯失敗。' : '處理完成！';
                updateStatus(finalMessage, false);

                setupDownloadButtons();
                downloadArea.classList.remove('hidden');

            } catch (error) {
                console.error("處理過程中發生錯誤:", error);
                updateStatus(`錯誤：${error.message}`, false);
            } finally {
                setLoadingState(false);
                updateProcessButtonState();
            }
        }

        async function extractTextFromPdf(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
            const chapters = [];
            let currentChapterText = '';
            const CHAPTER_CHAR_LIMIT = 8000; // Keep safely below the 10k API limit per item

            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const viewport = page.getViewport({ scale: 1 });
                const pageHeight = viewport.height, headerMargin = pageHeight * 0.1, footerMargin = pageHeight * 0.9;
                
                let pageItems = textContent.items.filter(item => {
                    const y = item.transform[5];
                    if (y > headerMargin && y < footerMargin) {
                        const trimmedText = item.str.trim();
                        return !/^\d+$/.test(trimmedText) || trimmedText.length > 4;
                    }
                    return false;
                });
                
                pageItems.sort((a, b) => b.transform[5] - a.transform[5]);
                let pageText = pageItems.map(item => item.str).join(' ').trim();
                
                if (pageText) {
                    if (currentChapterText.length + pageText.length > CHAPTER_CHAR_LIMIT && currentChapterText.length > 0) {
                        chapters.push(currentChapterText);
                        currentChapterText = pageText;
                    } else {
                        currentChapterText += (currentChapterText.length > 0 ? '\n\n' : '') + pageText;
                    }
                }
                
                const progress = Math.round((i / pdf.numPages) * 100);
                updateProgressBar(progress, `提取中 ${progress}%`);
            }
            if (currentChapterText.length > 0) {
                chapters.push(currentChapterText);
            }
            return chapters;
        }
        
        const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        function sanitizeTextForApi(text) {
            // Replaces C0 and C1 control characters with a space, except for HT, LF, CR.
            return text.replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F-\u009F]/g, ' ');
        }

        async function translateChaptersWithAzure(chapters, key, region, interBatchDelay) {
            const endpoint = 'https://corsproxy.io/?' + encodeURIComponent('https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&from=en&to=zh-Hant');
            
            const MAX_CHARS_PER_BATCH = 30000;
            const MAX_ITEMS_PER_REQUEST = 1000;

            const chunksToTranslate = chapters
                .map(ch => sanitizeTextForApi(ch).trim())
                .filter(ch => ch.length > 0)
                .map(ch => ({ 'Text': ch }));

            if (chunksToTranslate.length === 0) return chapters.map(() => '');

            const chunkBatches = [];
            let currentBatch = [];
            let currentCharCount = 0;
            for (const chunkObj of chunksToTranslate) {
                if (currentBatch.length > 0 && (currentCharCount + chunkObj.Text.length > MAX_CHARS_PER_BATCH || currentBatch.length >= MAX_ITEMS_PER_REQUEST)) {
                    chunkBatches.push(currentBatch);
                    currentBatch = [];
                    currentCharCount = 0;
                }
                currentBatch.push(chunkObj);
                currentCharCount += chunkObj.Text.length;
            }
            if (currentBatch.length > 0) {
                chunkBatches.push(currentBatch);
            }
            
            const totalBatches = chunkBatches.length;
            const averageApiTimePerBatch = 5;

            const calculateRemainingTime = (batchesLeft) => {
                if (batchesLeft <= 0) return 0;
                const remainingDelays = batchesLeft > 1 ? batchesLeft - 1 : 0;
                return (remainingDelays * (interBatchDelay / 1000)) + (batchesLeft * averageApiTimePerBatch);
            };

            const initialEstimatedSeconds = calculateRemainingTime(totalBatches);
            updateStatus(`正在準備翻譯 ${totalBatches} 個批次... 預計需要: ${formatTime(initialEstimatedSeconds)}`, true);
            
            let allTranslatedChunks = [];
            for (const [index, batch] of chunkBatches.entries()) {
                if (batch.length === 0) continue;

                const maxRetries = 5;
                let currentRetry = 0;
                let fallbackDelay = 5000;
                let batchFailed = false;

                while (currentRetry <= maxRetries) {
                    try {
                        const response = await fetch(endpoint, {
                            method: 'POST',
                            headers: {
                                'Ocp-apim-subscription-key': key,
                                'Ocp-apim-subscription-region': region,
                                'Content-Type': 'application/json; charset=UTF-8'
                            },
                            body: JSON.stringify(batch)
                        });

                        if (response.ok) {
                            const result = await response.json();
                            const translatedTexts = result.map(item => item.translations[0]?.text || '');
                            allTranslatedChunks.push(...translatedTexts);
                            batchFailed = false;
                            break; 
                        }

                        if (response.status === 401) {
                                throw new Error(`Azure 認證失敗: 請檢查您的訂閱金鑰和區域。`);
                        }
                        
                        if (response.status === 429 && currentRetry < maxRetries) {
                                const retryAfterHeader = response.headers.get('Retry-After');
                                let delayDuration = fallbackDelay;
                                if (retryAfterHeader && !isNaN(parseInt(retryAfterHeader, 10))) {
                                    delayDuration = (parseInt(retryAfterHeader, 10) + 1) * 1000;
                                }
                                console.warn(`請求頻率過高 (429)。將在 ${delayDuration / 1000} 秒後重試...`);
                                await delay(delayDuration);
                                fallbackDelay *= 2;
                                currentRetry++;
                                continue;
                        }
                        
                        const errorBodyText = await response.text();
                        const errorBody = JSON.parse(errorBodyText || '{}');
                        const finalErrorMessage = errorBody?.error?.message || `伺服器錯誤 (${response.status})`;
                        throw new Error(finalErrorMessage);

                    } catch (error) {
                        if (currentRetry >= maxRetries) {
                            console.error(`達到最大重試次數，放棄此批次。錯誤:`, error.message);
                            let userErrorMessage = `[翻譯失敗: ${error.message}]`;
                            if (error.message.toLowerCase().includes('quota')) {
                                userErrorMessage = '[翻譯失敗: API 使用額度已用完。請檢查您的 Azure 帳戶。]';
                            } else if (error.message.includes('exceeded request limits') || error.message.includes('429')) {
                                userErrorMessage = '[翻譯失敗: 請求頻率超限。請嘗試增加「批次間延遲」時間後再試一次。]';
                            }
                            const errorMessages = batch.map(() => userErrorMessage);
                            allTranslatedChunks.push(...errorMessages);
                            batchFailed = true;
                            break;
                        }
                        console.warn(`請求失敗，將在 ${fallbackDelay / 1000} 秒後重試...`, error);
                        await delay(fallbackDelay);
                        fallbackDelay *= 2;
                        currentRetry++;
                    }
                }
                
                if (batchFailed && allTranslatedChunks[0]?.includes('Azure 認證失敗')) {
                    throw new Error('Azure 認證失敗，處理已中止。');
                }

                const progress = Math.round((allTranslatedChunks.length / chunksToTranslate.length) * 100);
                const batchesLeft = totalBatches - (index + 1);
                const estimatedSecondsRemaining = calculateRemainingTime(batchesLeft);
                
                updateProgressBar(progress, `翻譯中 ${progress}%`);

                if (batchesLeft > 0) {
                    updateStatus(`已完成 ${index + 1}/${totalBatches} 批... 預計剩餘時間: ${formatTime(estimatedSecondsRemaining)}`, true);
                } else {
                    updateStatus(`已完成 ${index + 1}/${totalBatches} 批... 正在完成最後處理...`, true);
                }

                if (index < totalBatches - 1) {
                    await delay(interBatchDelay); 
                }
            }
            
            const finalResults = [];
            let translatedChunkIndex = 0;
            for (let i = 0; i < chapters.length; i++) {
                if (chapters[i].trim().length > 0) {
                    finalResults.push(allTranslatedChunks[translatedChunkIndex] || `[翻譯失敗]`);
                    translatedChunkIndex++;
                } else {
                    finalResults.push('');
                }
            }
            
            return finalResults;
        }

        async function translateChaptersWithDeepL(chapters, key) {
            const endpoint = 'https://corsproxy.io/?' + encodeURIComponent('https://api-free.deepl.com/v2/translate');
            
            const CHAR_LIMIT_PER_CHUNK = 999;
            const INTER_REQUEST_DELAY = 1100;

            // 1. Flatten all chapters into small, translatable chunks
            const allChunksToTranslate = [];
            chapters.forEach((chapter, chapterIndex) => {
                const sanitizedChapter = sanitizeTextForApi(chapter).trim();
                if (sanitizedChapter.length === 0) {
                    return;
                }

                let remainingText = sanitizedChapter;
                while (remainingText.length > 0) {
                    let splitPoint = Math.min(remainingText.length, CHAR_LIMIT_PER_CHUNK);
                    
                    if (splitPoint < remainingText.length) {
                        let lastNewline = remainingText.lastIndexOf('\n', splitPoint);
                        if (lastNewline > splitPoint / 2) { 
                            splitPoint = lastNewline + 1;
                        } else {
                            let lastSpace = remainingText.lastIndexOf(' ', splitPoint);
                            if (lastSpace > splitPoint / 2) {
                                splitPoint = lastSpace + 1;
                            }
                        }
                    }
                    
                    const chunkText = remainingText.substring(0, splitPoint);
                    allChunksToTranslate.push({ text: chunkText, originalChapterIndex: chapterIndex });
                    remainingText = remainingText.substring(splitPoint);
                }
            });

            if (allChunksToTranslate.length === 0) return chapters.map(() => '');

            // 2. Prepare for UI updates
            const totalChunks = allChunksToTranslate.length;
            const averageApiTimePerChunk = 1.5; 
            const calculateRemainingTime = (chunksLeft) => {
                 if (chunksLeft <= 0) return 0;
                 return chunksLeft * averageApiTimePerChunk;
            }

            const initialEstimatedSeconds = calculateRemainingTime(totalChunks);
            updateStatus(`正在準備翻譯 ${totalChunks} 個區塊... 預計需要: ${formatTime(initialEstimatedSeconds)}`, true);

            // 3. Translate all chunks one by one
            let allTranslatedTexts = [];
            for (const [index, chunkData] of allChunksToTranslate.entries()) {
                 const maxRetries = 3;
                 let currentRetry = 0;
                 let fallbackDelay = 2000;
                 
                 while (currentRetry <= maxRetries) {
                    try {
                        const response = await fetch(endpoint, {
                            method: 'POST',
                            headers: {
                                'Authorization': `DeepL-Auth-Key ${key}`,
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                text: [chunkData.text],
                                target_lang: 'ZH-HANT' 
                            })
                        });

                        if (response.ok) {
                            const result = await response.json();
                            allTranslatedTexts.push(result.translations[0].text);
                            break; 
                        }
                        
                        if (response.status === 403) {
                             throw new Error('DeepL 認證失敗: 請檢查您的 API 金鑰。');
                        }
                        
                        if (response.status === 429 || response.status === 503) { 
                            console.warn(`DeepL API 速率限制或暫時無法使用 (${response.status})。 ${fallbackDelay / 1000} 秒後重試...`);
                            await delay(fallbackDelay);
                            fallbackDelay *= 2; 
                            currentRetry++;
                            continue;
                        }

                        const errorBodyText = await response.text();
                        const errorBody = JSON.parse(errorBodyText || '{"message": "未知錯誤"}');
                        throw new Error(errorBody.message || `未知錯誤 (${response.status})`);

                    } catch (error) {
                        if (currentRetry >= maxRetries) {
                            console.error(`達到最大重試次數，放棄此區塊。錯誤:`, error.message);
                            let userErrorMessage = `[翻譯失敗: ${error.message}]`;
                            if (error.message.toLowerCase().includes('quota')) {
                                userErrorMessage = '[翻譯失敗: API 使用額度已用完。請檢查您的 DeepL 帳戶。]';
                            }
                            allTranslatedTexts.push(userErrorMessage);
                            break;
                        }
                         console.warn(`請求失敗，將在 ${fallbackDelay / 1000} 秒後重試...`, error);
                         await delay(fallbackDelay);
                         fallbackDelay *= 2;
                         currentRetry++;
                    }
                }
                
                // Update UI after each translation
                const progress = Math.round(((index + 1) / totalChunks) * 100);
                const chunksLeft = totalChunks - (index + 1);
                const estimatedSecondsRemaining = calculateRemainingTime(chunksLeft);
                
                updateProgressBar(progress, `翻譯中 ${progress}%`);
                if (chunksLeft > 0) {
                     updateStatus(`已完成 ${index + 1}/${totalChunks} 個區塊... 預計剩餘時間: ${formatTime(estimatedSecondsRemaining)}`, true);
                }

                if (index < totalChunks - 1) {
                    await delay(INTER_REQUEST_DELAY);
                }
            }
             
             // 4. Reconstruct the translated chapters
             const finalResults = Array(chapters.length).fill('');
             allTranslatedTexts.forEach((translatedText, i) => {
                 const originalIndex = allChunksToTranslate[i].originalChapterIndex;
                 finalResults[originalIndex] += translatedText;
             });
             
             return finalResults;
        }

        // --- Download & File Generation Functions ---

        function setupDownloadButtons() {
            downloadButtonsContainer.innerHTML = '';
            
            if (currentMode === 'translate') {
                createDownloadButton('downloadTranslatedEpubBtn', '純翻譯 EPUB', 'bg-blue-500', handleDownloadTranslatedEpub);
                createDownloadButton('downloadTranslatedTxtBtn', '純翻譯 .txt', 'bg-green-500', handleDownloadTranslatedTxt);
                createDownloadButton('downloadBilingualEpubBtn', '中英對照 EPUB', 'bg-purple-500', handleDownloadBilingualEpub);
                createDownloadButton('downloadBilingualTxtBtn', '中英對照 .txt', 'bg-purple-600', handleDownloadBilingualTxt);
            } else {
                createDownloadButton('downloadOriginalEpubBtn', '原文 EPUB', 'bg-blue-500', handleDownloadOriginalEpub);
                createDownloadButton('downloadOriginalTxtBtn', '原文 .txt', 'bg-gray-500', handleDownloadOriginalTxt);
            }
        }

        function createDownloadButton(id, text, bgColor, clickHandler) {
            const button = document.createElement('button');
            button.id = id;
            button.textContent = text;
            button.className = `${bgColor} hover:${bgColor.replace('500', '600')} text-white font-bold py-2 px-6 rounded-lg transition-all duration-300 shadow-md`;
            button.addEventListener('click', clickHandler);
            downloadButtonsContainer.appendChild(button);
        }

        async function handleDownloadOriginalEpub() {
            const epubZip = await createEpub(selectedFile.name.replace(/\.pdf$/i, ''), originalChapters);
            const blob = await epubZip.generateAsync({ type: 'blob', mimeType: "application/epub+zip" });
            downloadBlob(blob, '_原文.epub');
        }
        function handleDownloadOriginalTxt() {
            const content = originalChapters.join('\n\n---\n\n');
            downloadAsTxt(content, '_原文');
        }
        async function handleDownloadTranslatedEpub() {
            const epubZip = await createEpub(selectedFile.name.replace(/\.pdf$/i, ''), translatedChapters);
            const blob = await epubZip.generateAsync({ type: 'blob', mimeType: "application/epub+zip" });
            downloadBlob(blob, '_翻譯.epub');
        }
        function handleDownloadTranslatedTxt() {
            const content = translatedChapters.join('\n\n---\n\n');
            downloadAsTxt(content, '_翻譯');
        }
        async function handleDownloadBilingualEpub() {
            const epubZip = await createEpub(selectedFile.name.replace(/\.pdf$/i, ''), originalChapters, translatedChapters);
            const blob = await epubZip.generateAsync({ type: 'blob', mimeType: "application/epub+zip" });
            downloadBlob(blob, '_中英對照.epub');
        }
        function handleDownloadBilingualTxt() {
            let bilingualContent = '';
            for(let i = 0; i < originalChapters.length; i++) {
                bilingualContent += `【原文】\n${originalChapters[i]}\n\n`;
                bilingualContent += `【譯文】\n${translatedChapters[i] || ''}\n\n--------------------\n\n`;
            }
            downloadAsTxt(bilingualContent, '_中英對照');
        }

        function downloadAsTxt(text, suffix) {
            const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
            downloadBlob(blob, `${suffix}.txt`);
        }
        
        function downloadBlob(blob, suffix) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const originalName = selectedFile.name.split('.').slice(0, -1).join('.');
            a.download = `${originalName}${suffix}`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function createEpub(title, mainChapters, secondaryChapters = null) {
            const zip = new JSZip();
            const uuid = `urn:uuid:${crypto.randomUUID()}`;
            zip.file("mimetype", "application/epub+zip", { compression: "STORE" });
            const containerXml = `<?xml version="1.0" encoding="UTF-8"?><container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container"><rootfiles><rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/></rootfiles></container>`;
            zip.file("META-INF/container.xml", containerXml);
            
            let css = `body { font-family: sans-serif; line-height: 1.6; } p { margin: 0 0 1em 0; text-indent: 2em; }`;
            if (secondaryChapters) {
                // For bilingual mode, original is secondary, translated is main
                css += `p.secondary { color: #555; font-size: 0.9em; text-indent: 0; margin-left: 2em; border-left: 2px solid #ccc; padding-left: 1em; margin-bottom: 0.5em;} p.main { text-indent: 2em; margin-bottom: 2em; }`;
            }
            zip.file("OEBPS/stylesheet.css", css);

            const chaptersToIterate = secondaryChapters ? secondaryChapters : mainChapters;
            chaptersToIterate.forEach((content, index) => {
                const chapterId = index + 1;
                let htmlContent = '';
                if (secondaryChapters) { // Bilingual mode
                    const originalParagraphs = (mainChapters[index] || "").split('\n\n');
                    const translatedParagraphs = (secondaryChapters[index] || "").split('\n\n');
                    const maxLen = Math.max(originalParagraphs.length, translatedParagraphs.length);
                    for(let i = 0; i < maxLen; i++) {
                        const translatedP = (translatedParagraphs[i] || "").trim();
                        const originalP = (originalParagraphs[i] || "").trim();
                        if (translatedP) htmlContent += `<p class="main">${translatedP.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p>`;
                        if (originalP) htmlContent += `<p class="secondary">${originalP.replace(/&/g, '&lt;').replace(/>/g, '&gt;')}</p>`;
                    }
                } else { // Single language mode
                    htmlContent = (content || "").split('\n\n').map(p => `<p>${p.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p>`).join('\n');
                }
                const xhtml = `<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>第 ${chapterId} 章</title><link rel="stylesheet" type="text/css" href="stylesheet.css"/></head><body>${htmlContent}</body></html>`;
                zip.file(`OEBPS/chapter${chapterId}.xhtml`, xhtml);
            });

            let tocNcx = `<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE ncx PUBLIC "-//NISO//DTD ncx 2005-1//EN" "http://www.daisy.org/z3986/2005/ncx-2005-1.dtd"><ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1"><head><meta name="dtb:uid" content="${uuid}"/><meta name="dtb:depth" content="1"/><meta name="dtb:totalPageCount" content="0"/><meta name="dtb:maxPageNumber" content="0"/></head><docTitle><text>${title}</text></docTitle><navMap>`;
            chaptersToIterate.forEach((_, index) => {
                tocNcx += `<navPoint id="navPoint-${index + 1}" playOrder="${index + 1}"><navLabel><text>第 ${index + 1} 章</text></navLabel><content src="chapter${index + 1}.xhtml"/></navPoint>`;
            });
            tocNcx += `</navMap></ncx>`;
            zip.file("OEBPS/toc.ncx", tocNcx);

            let contentOpf = `<?xml version="1.0" encoding="UTF-8"?><package xmlns="http://www.idpf.org/2007/opf" unique-identifier="BookId" version="2.0"><metadata xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:opf="http://www.idpf.org/2007/opf"><dc:title>${title}</dc:title><dc:language>zh-TW</dc:language><dc:identifier id="BookId" opf:scheme="UUID">${uuid}</dc:identifier></metadata><manifest><item id="ncx" href="toc.ncx" media-type="application/x-dtbncx+xml"/><item id="css" href="stylesheet.css" media-type="text/css"/>`;
            chaptersToIterate.forEach((_, index) => {
                contentOpf += `<item id="chapter${index + 1}" href="chapter${index + 1}.xhtml" media-type="application/xhtml+xml"/>`;
            });
            contentOpf += `</manifest><spine toc="ncx">`;
            chaptersToIterate.forEach((_, index) => {
                contentOpf += `<itemref idref="chapter${index + 1}"/>`;
            });
            contentOpf += `</spine></package>`;
            zip.file("OEBPS/content.opf", contentOpf);

            return zip;
        }
    </script>
</body>
</html>

